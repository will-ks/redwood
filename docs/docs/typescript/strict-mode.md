---
description: TS Strict mode tips and tricks
---

# TypeScript Strict Mode

Looks like you're ready to level up your TypeScript game!
Redwood supports [strict mode](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#strictness), but doesn't enable it by default.
While strict mode gives you a lot more safety, it makes your code a bit more verbose and requires you to make small manual changes if you use the generators.

## Enabling strict mode

Enable strict mode by setting `strict` to true in `web/tsconfig.json` and `api/tsconfig.json`, and if you're using scripts in `scripts/tsconfig.json`:

```json title="web/tsconfig.json, api/tsconfig.json, scripts/tsconfig.json"
{
  "compilerOptions": {
    "noEmit": true,
    "allowJs": true,
    // highlight-next-line
    "strict": true,
    // ...
  }
  // ...
}
```

Redwood's type generator behaves a bit differently in strict mode, so now that you've opted in, make sure to generate types:

```
yarn rw g types
```

## Manual tweaks to generated code

Now that you're in strict mode, there are some changes you need to make to get rid of those pesky red underlines!

### Service functions & tests

By default, Redwood's generators assume that Service functions don't require any parameters. For example, [in the tutorial](../tutorial/chapter2/side-quest.md), the `posts` Service function generated by the scaffold command doesn't specify any parameters:

```ts title="src/services/posts/posts.test.ts"
// highlight-next-line
export const posts: QueryResolvers['posts'] = () => {
  return db.post.findMany()
}
```

While this is true, in the strictest sense, all GraphQL resolvers (and most of your Service functions _do_ end up becoming GraphQL resolvers) take some sort of input, so you'll need to modify the calls to your Service functions that have been typed with `QueryResolvers` or `MutationResolvers`:

```ts title="src/services/posts/posts.test.ts"
describe('posts', () => {
  scenario('returns all posts', async (scenario: StandardScenario) => {
    const result = await posts() // ðŸ›‘ error
    const result = await posts({}) // âœ…

    expect(result.length).toEqual(Object.keys(scenario.post).length)
  })
})
```

:::info Why this happens in strict mode

In strict mode, Redwood generates different types for `QueryResolvers` and `MutationResolvers`, where the first argumentâ€”`args`â€”is no longer optional.

We realize that this isn't a perfect solution, but the tension comes from the fact that we can't define different types for when a Service function is called from inside GraphQL (as a resolver) versus when it's called from anywhere else.

:::

### `null` and `undefined` in Services

One of the challenges in the GraphQL-Prisma world is the difference in the way they treats optionals:

- for GraphQL, optional fields can be `null`
- but For Prisma, `null` is a value, and `undefined` means "do nothing"

This is covered in detail in [Prisma's docs](https://www.prisma.io/docs/concepts/components/prisma-client/null-and-undefined), which we strongly recommend reading.
But the gist of it is that, for Prisma's create and update operations, you have to make sure `null`s are converted to `undefined` from your GraphQL mutation inputs.
One way to do this is to use the [dnull](https://www.npmjs.com/package/dnull) package:

```
yarn workspace api add dnull
```

```ts title=api/src/services/users.ts
// highlight-next-line
import { dnull } from "dnull"

export const updateUser: MutationResolvers["updateUser"] = ({ id, input }) => {
  return db.user.update({
    // highlight-next-line
    data: dnull(input),
    where: { id },
  })
}
```

### Roles checks for CurrentUser in `src/lib/auth`

When you setup auth, Redwood includes some template code for handling roles with the `hasRole` function.
While Redwood does runtime checks to make sure it doesn't access roles if it doesn't exist, TypeScript in strict mode will highlight errors, depending on whether you are returning `roles`, and whether those roles are `string` or `string[]`

```typescript
export const hasRole = (roles: AllowedRoles): boolean => {
  if (!isAuthenticated()) {
    return false
  }

  // highlight-next-line
  const currentUserRoles = context.currentUser?.roles
  // Error: Property 'roles' does not exist on type '{ id: number; }'.ts(2339)
```

You'll have to adjust the generated code depending on your User model.

<details>
<summary>Example code diffs</summary>

#### A. If your project does not use roles

If your `getCurrentUser` doesn't return `roles`, and you don't use this functionality, you can safely remove the `hasRole` function.

#### B. Roles on current user is a string

Alternatively, if  you define the roles as a string, you can remove the code that does checks against Arrays

```diff title="api/src/lib/auth.ts"
export const hasRole = (roles: AllowedRoles): boolean => {
  if (!isAuthenticated()) {
    return false
  }

  const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string') {
-    if (typeof currentUserRoles === 'string') {
      return currentUserRoles === roles
-    }
  }

  if (Array.isArray(roles)) {
-    if (Array.isArray(currentUserRoles)) {
-      return currentUserRoles?.some((allowedRole) =>
-        roles.includes(allowedRole)
-      )
-    } else if (typeof currentUserRoles === 'string') {
      // roles to check is an array, currentUser.roles is a string
      return roles.some((allowedRole) => currentUserRoles === allowedRole)
-    }
  }

  // roles not found
  return false
}
```

#### C. Roles on current user is an Array of strings

If in your User model, roles are an array of strings, and can never be just a string, you can safely remove most of the code

```diff title="api/src/lib/auth.ts"
export const hasRole = (roles: AllowedRoles): boolean => {
  if (!isAuthenticated()) {
    return false
  }

 const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string') {
-    if (typeof currentUserRoles === 'string') {
-      return currentUserRoles === roles
-    } else if (Array.isArray(currentUserRoles)) {
      // roles to check is a string, currentUser.roles is an array
      return currentUserRoles?.some((allowedRole) => roles === allowedRole)
-    }
  }

  if (Array.isArray(roles)) {
-    if (Array.isArray(currentUserRoles)) {
      return currentUserRoles?.some((allowedRole) =>
        roles.includes(allowedRole)
      )
-    } else if (typeof currentUserRoles === 'string') {
-      return roles.some(
-        (allowedRole) => currentUserRoles === allowedRole
-      )
    }
  }

  // roles not found
  return false
}
```
</details>

### `getCurrentUser` in `api/src/lib/auth.ts`

Depending on your auth providerâ€”i.e., anything but dbAuthâ€”because it could change based on your account settings (if you include roles or other metadata), we can't know the shape of your decoded token at setup time.
So you'll have to make sure that the `getCurrentUser` function is typed.

To help you get started, the comments above the `getCurrentUser` function describe its parameters' types. We recommend typing `decoded` without using imported types from Redwood, as this may be a little too generic!

```ts title='api/src/lib/auth.ts'
import type { AuthContextPayload } from '@redwoodjs/api'

// Example 1: typing directly
export const getCurrentUser: CurrentUserFunc = async (
  decoded: { id: string, name: string },
  { token, type }: { token: string, type: string },
) => {
  // ...
}

// Example 2: Using AuthContextPayload
export const getCurrentUser: CurrentUserFunc = async (
  decoded: { id: string, name: string },
  { token, type }: AuthContextPayload[1],
  { event, context }: AuthContextPayload[2]
) => {
  // ...
}
```
